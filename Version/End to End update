To implement a Jenkins Pipeline that automates semantic versioning updates and pushes these changes to a GitHub repository, you'll follow these steps:

1. **Fetch the Current Version**: Read the current version from a file (e.g., `version.txt` or `package.json`).
2. **Update the Version**: Increment the version based on semantic versioning rules (major, minor, patch).
3. **Commit and Tag**: Commit the updated version and create a Git tag.
4. **Push Changes**: Push the commit and the tag to the GitHub repository.

Below is an example Jenkinsfile that covers these steps. This example assumes you are using a simple `version.txt` file for versioning. For more complex projects, the script might need adjustments based on how versioning is managed (e.g., `package.json` for Node.js, `pom.xml` for Maven, etc.).

### Jenkinsfile Example

```groovy
pipeline {
    agent any

    environment {
        REPO_URL = 'https://github.com/your-username/your-repo.git' // Replace with your repository URL
        CREDENTIALS_ID = 'your-credentials-id' // Replace with your Jenkins credentials ID
        VERSION_FILE = 'version.txt' // Replace with the path to your version file
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    // Checkout the code
                    checkout([$class: 'GitSCM', branches: [[name: '*/main']],
                              userRemoteConfigs: [[url: REPO_URL, credentialsId: CREDENTIALS_ID]]])
                }
            }
        }

        stage('Read Current Version') {
            steps {
                script {
                    // Read the current version from the version file
                    def currentVersion = readFile(env.VERSION_FILE).trim()
                    echo "Current version: ${currentVersion}"
                    env.CURRENT_VERSION = currentVersion
                }
            }
        }

        stage('Increment Version') {
            steps {
                script {
                    // Increment the version (patch in this example)
                    def parts = env.CURRENT_VERSION.tokenize('.')
                    def newVersion = "${parts[0]}.${parts[1]}.${parts[2].toInteger() + 1}"
                    echo "New version: ${newVersion}"

                    // Write the new version back to the file
                    writeFile(file: env.VERSION_FILE, text: newVersion)
                    env.NEW_VERSION = newVersion
                }
            }
        }

        stage('Commit and Tag') {
            steps {
                script {
                    // Commit the version file and tag the commit
                    sh 'git config user.name "Jenkins"'
                    sh 'git config user.email "jenkins@example.com"'
                    sh "git add ${env.VERSION_FILE}"
                    sh "git commit -m 'Release version ${env.NEW_VERSION}'"
                    sh "git tag v${env.NEW_VERSION}"
                }
            }
        }

        stage('Push Changes and Tag') {
            steps {
                script {
                    // Push the changes and tags
                    sh "git push origin main"
                    sh "git push origin v${env.NEW_VERSION}"
                }
            }
        }
    }

    post {
        success {
            echo 'Version update and push successful!'
        }
        failure {
            echo 'Pipeline failed. Check the logs for details.'
        }
    }
}
```

### Key Points:

1. **Environment Variables**:
   - `REPO_URL`: The GitHub repository URL.
   - `CREDENTIALS_ID`: Jenkins credentials ID used for authentication.
   - `VERSION_FILE`: The path to the file containing the version number.

2. **Stages**:
   - **Checkout**: Clones the main branch of the repository.
   - **Read Current Version**: Reads the current version from the `version.txt` file.
   - **Increment Version**: Increments the version number. In this example, it increments the patch number. You can modify the logic to handle major or minor version increments as needed.
   - **Commit and Tag**: Commits the updated version file and tags the commit.
   - **Push Changes and Tag**: Pushes the commit and the tag to the remote repository.

3. **Post Actions**:
   - Handles notifications or additional actions based on the success or failure of the pipeline.

### Important Considerations:

- **Git Configuration**: Ensure Jenkins has access to the repository and the correct permissions to push changes and tags.
- **Versioning Logic**: Adapt the version increment logic based on your projectâ€™s requirements (e.g., choosing between major, minor, or patch updates).
- **Commit and Tagging**: Ensure that the tag name format (e.g., `v1.0.1`) matches your project's tagging convention.

Replace placeholders like `'your-repository-url'`, `'your-credentials-id'`, and `'version.txt'` with your actual repository details and version file path. This Jenkinsfile should be thoroughly tested in a staging or development environment before use in production to ensure it behaves as expected.