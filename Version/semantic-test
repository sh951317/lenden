To create a Jenkins pipeline that satisfies the requirements mentioned in the image, you can follow these steps. This pipeline will focus on semantic versioning, updating image versions, and modifying the `values.yaml` file.

Here's an example Jenkins pipeline script written in a declarative pipeline syntax:

```groovy
pipeline {
    agent any

    environment {
        // Define environment variables if necessary
        BRANCH_NAME = ''  // This will hold the branch name
        BASE_IMAGE = ''   // This will hold the base image details
        NEW_VERSION = ''  // This will hold the new version
    }

    stages {
        stage('Get Branch Name') {
            steps {
                script {
                    BRANCH_NAME = env.BRANCH_NAME
                    echo "Branch Name: ${BRANCH_NAME}"
                }
            }
        }

        stage('Check Base Image') {
            steps {
                script {
                    // Assuming we are using OpenShift CLI
                    BASE_IMAGE = sh(script: "oc get is <image-stream-name> -o jsonpath='{.status.tags[?(@.tag==\"latest\")].items[0].image}'", returnStdout: true).trim()
                    echo "Base Image: ${BASE_IMAGE}"
                }
            }
        }

        stage('Update Image Version') {
            steps {
                script {
                    // Logic to determine the new version based on semantic versioning
                    // This could involve parsing the branch name, current version, etc.
                    NEW_VERSION = '1.0.0' // Placeholder for new version logic
                    echo "New Image Version: ${NEW_VERSION}"
                }
            }
        }

        stage('Update values.yaml') {
            steps {
                script {
                    // Update the values.yaml file with the new image version
                    sh """
                    sed -i 's/tag: .*/tag: ${NEW_VERSION}/' path/to/values.yaml
                    """
                    echo "Updated values.yaml with new version: ${NEW_VERSION}"
                }
            }
        }

        stage('Commit and Push Changes') {
            steps {
                script {
                    sh """
                    git add path/to/values.yaml
                    git commit -m "Update image version to ${NEW_VERSION}"
                    git push origin ${BRANCH_NAME}
                    """
                    echo "Committed and pushed changes"
                }
            }
        }
    }

    post {
        success {
            echo 'Pipeline executed successfully'
        }
        failure {
            echo 'Pipeline execution failed'
        }
    }
}
```

### Key Points:
1. **Get Branch Name**: Retrieves the current branch name, which might be used to determine the new version number.
2. **Check Base Image**: Retrieves the current base image details from OpenShift, which might be necessary for the versioning logic.
3. **Update Image Version**: Contains logic for determining the new version number based on the branch name and existing versions.
4. **Update values.yaml**: Updates the `values.yaml` file with the new version number.
5. **Commit and Push Changes**: Commits the updated `values.yaml` file and pushes the changes to the repository.

### Prerequisites:
- Jenkins server with appropriate plugins installed (e.g., Git, OpenShift CLI).
- Credentials configured in Jenkins for Git and OpenShift.
- The script assumes a basic understanding of shell scripting, semantic versioning, and working with YAML files.

Customize the pipeline script according to your project's specific needs, including the logic for determining the new version number.